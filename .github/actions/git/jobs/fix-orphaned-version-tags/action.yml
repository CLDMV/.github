name: "ðŸ”§ Fix Orphaned Major Version Tags"
description: "Detects and fixes major version tags that don't point to the latest patch version"

outputs:
  fixed-tags:
    description: "List of major version tags that were fixed"
    value: ${{ steps.fix-orphans.outputs.fixed-tags }}
  orphans-found:
    description: "Whether any orphaned tags were found and fixed"
    value: ${{ steps.fix-orphans.outputs.orphans-found }}

runs:
  using: composite
  steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect and fix orphaned major/minor tags (gather)
      id: fix-orphans
      shell: bash
      run: |
        node <<'EOF'
        const { execSync } = require('child_process');
        const fs = require('fs');

        const out = process.env.GITHUB_OUTPUT;
        const log = (...a) => console.log(...a);
        const sh = (cmd) => execSync(cmd, { stdio: ['ignore', 'pipe', 'inherit'] }).toString().trim();

        // Ensure tags are up-to-date (checkout used fetch-depth: 0 already)
        try { sh('git fetch --prune --tags --force'); } catch {}

        log('ðŸ” Checking for orphaned major and minor version tags...');

        // Helpers
        const verKey = (t) => t.replace(/^v/, '').split('.').map(n => parseInt(n, 10));
        const cmp = (a, b) => {
          const [A,B,C] = verKey(a);
          const [D,E,F] = verKey(b);
          return (A-D) || (B-E) || (C-F);
        };

        // All patch tags vX.Y.Z (sorted ascending)
        const allTags = sh('git tag -l "v*.*.*"')
          .split('\n').filter(Boolean).sort(cmp);

        if (allTags.length === 0) {
          fs.appendFileSync(out, `orphans-found=false\n`);
          fs.appendFileSync(out, `fixed-tags=\n`);
          fs.appendFileSync(out, `orphaned-tags-json=[]\n`);
          log('âœ… No versioned tags found (v*.*.*).');
          process.exit(0);
        }

        const currentTag = allTags[allTags.length - 1];
        const [curMaj, curMin] = (() => {
          const [M, m] = verKey(currentTag);
          return [`v${M}`, `v${M}.${m}`];
        })();

        log(`ðŸ·ï¸ Current tag: ${currentTag} (major: ${curMaj}, minor: ${curMin})`);

        // All existing ref tags
        const allRefTags = sh('git tag -l').split('\n').filter(Boolean);
        const existingMajors = allRefTags.filter(t => /^v\d+$/.test(t)).sort((a,b) => verKey(a)[0]-verKey(b)[0]);
        const existingMinors = allRefTags.filter(t => /^v\d+\.\d+$/.test(t)).sort((a,b) => {
          const [A,B] = verKey(a); const [D,E] = verKey(b);
          return (A-D) || (B-E);
        });

        const orphanRows = []; // { tagName, targetSha, latestPatch }
        let fixedTagsLines = [];
        let orphansFound = false;

        // Utility: get commit sha of a tag/ref (or '' if missing)
        const rev = (ref) => {
          try { return sh(`git rev-list -n 1 "${ref}"`); } catch { return ''; }
        };

        // Latest patch for a given major number
        const latestPatchForMajor = (M) => {
          const prefix = `v${M}.`;
          const picks = allTags.filter(t => t.startsWith(prefix));
          return picks.length ? picks[picks.length - 1] : '';
        };

        // Latest patch for a given minor string "X.Y"
        const latestPatchForMinor = (minor) => {
          const prefix = `v${minor}.`;
          const picks = allTags.filter(t => t.startsWith(prefix));
          return picks.length ? picks[picks.length - 1] : '';
        };

        // ---- Check major tags (skip current major) ----
        for (const majorTag of existingMajors) {
          if (majorTag === curMaj) {
            log(`â­ï¸ Skipping ${majorTag} (current major version - handled by regular update)`);
            continue;
          }
          log(`ðŸ” Checking existing major tag: ${majorTag}`);
          const M = verKey(majorTag)[0];
          const latest = latestPatchForMajor(M);
          if (!latest) continue;

          const majorCommit = rev(majorTag);
          const latestCommit = rev(latest);
          log(`  ðŸ“ ${majorTag} points to: ${majorCommit}`);
          log(`  ðŸ“ ${latest} points to: ${latestCommit}`);

          if (majorCommit && majorCommit !== latestCommit) {
            log(`ðŸš¨ Orphaned major tag detected: ${majorTag} should point to ${latest}`);
            orphanRows.push({ tagName: majorTag, targetSha: latestCommit, latestPatch: latest });
            fixedTagsLines.push(`${majorTag} â†’ ${latest}`);
            orphansFound = true;
          } else {
            log(`âœ… ${majorTag} correctly points to ${latest}`);
          }
        }

        // ---- Check minor tags (skip current minor) ----
        for (const minorTag of existingMinors) {
          if (minorTag === curMin) {
            log(`â­ï¸ Skipping ${minorTag} (current minor version - handled by regular update)`);
            continue;
          }
          log(`ðŸ” Checking existing minor tag: ${minorTag}`);
          const [M, m] = verKey(minorTag);
          const latest = latestPatchForMinor(`${M}.${m}`);
          if (!latest) continue;

          const minorCommit = rev(minorTag);
          const latestCommit = rev(latest);
          log(`  ðŸ“ ${minorTag} points to: ${minorCommit}`);
          log(`  ðŸ“ ${latest} points to: ${latestCommit}`);

          if (minorCommit && minorCommit !== latestCommit) {
            log(`ðŸš¨ Orphaned minor tag detected: ${minorTag} should point to ${latest}`);
            orphanRows.push({ tagName: minorTag, targetSha: latestCommit, latestPatch: latest });
            fixedTagsLines.push(`${minorTag} â†’ ${latest}`);
            orphansFound = true;
          } else {
            log(`âœ… ${minorTag} correctly points to ${latest}`);
          }
        }

        // ----- Outputs -----
        const fixedTagsText = fixedTagsLines.join('\n');

        // fixed-tags can be multi-line -> use multiline output syntax
        fs.appendFileSync(out, `fixed-tags<<EOF\n${fixedTagsText}\nEOF\n`);
        fs.appendFileSync(out, `orphans-found=${orphansFound}\n`);

        if (orphansFound) {
          // Build compact JSON array [{tag, sha}]
          const tagData = orphanRows.map(r => ({ tag: r.tagName, sha: r.targetSha }));
          const compact = JSON.stringify(tagData);
          fs.appendFileSync(out, `orphaned-tags-json=${compact}\n`);
          log('ðŸ”§ Orphaned tags JSON:', compact);
        } else {
          fs.appendFileSync(out, `orphaned-tags-json=[]\n`);
          log('âœ… No orphaned major/minor version tags found');
        }
        EOF

    - name: Fix orphaned tags using modular GitHub API action
      if: steps.fix-orphans.outputs.orphans-found == 'true'
      uses: CLDMV/.github/.github/actions/github/api/update-tag@v1
      with:
        tag_data: ${{ steps.fix-orphans.outputs.orphaned-tags-json }}
        github_token: ${{ github.token }}
