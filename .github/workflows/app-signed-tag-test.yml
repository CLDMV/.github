name: App Tag (signed, annotated, via App token)

on:
  workflow_dispatch:
    inputs:
      tag_name:
        description: "Tag name to (create or) move (signed annotated)"
        default: "v-app-test"
        required: true
      tag_message:
        description: "Tag message"
        default: "Signed tag created/updated by CLDMV App workflow"
        required: true

permissions:
  contents: write

jobs:
  tag_with_git_signed:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (full history for tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute first and last commit SHAs
        id: shas
        shell: bash
        run: |
          set -euo pipefail
          FIRST_SHA="$(git rev-list --max-parents=0 HEAD | tail -n1)"
          LAST_SHA="$(git rev-parse HEAD)"
          echo "first=${FIRST_SHA}" >> "$GITHUB_OUTPUT"
          echo "last=${LAST_SHA}"   >> "$GITHUB_OUTPUT"
          echo "First: $FIRST_SHA"
          echo "Last : $LAST_SHA"

      - name: Create installation access token for the App
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.CLDMV_BOT_APP_ID }}
          private-key: ${{ secrets.CLDMV_BOT_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          # installation-id omitted: auto-detects installation for this repo

      - name: Install gpg + jq
        run: |
          sudo apt-get update
          sudo apt-get install -y gnupg jq

      - name: Import GPG private key
        id: gpg
        env:
          GPG_PRIVATE_KEY: ${{ secrets.CLDMV_BOT_GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.CLDMV_BOT_GPG_PASSPHRASE }}
        run: |
          set -euo pipefail

          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg

          # Configure GPG for non-interactive use in CI
          echo "use-agent" >> ~/.gnupg/gpg.conf
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpgconf --kill gpg-agent || true

          # Import the armored private key from secrets
          printf '%s' "$GPG_PRIVATE_KEY" > /tmp/private.key
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --import /tmp/private.key

          echo "Imported secret keys:"
          gpg --list-secret-keys --keyid-format LONG

          # Capture the first secret key ID
          KEYID="$(gpg --list-secret-keys --keyid-format LONG | awk '/^sec/{print $2}' | sed 's#.*/##' | head -n1)"
          if [ -z "$KEYID" ]; then
            echo "No secret key imported"; exit 1
          fi
          echo "keyid=$KEYID" >> "$GITHUB_OUTPUT"

      - name: Configure Git identity & signing
        id: gitcfg
        env:
          TAGGER_NAME: ${{ secrets.CLDMV_BOT_NAME }}
          TAGGER_EMAIL: ${{ secrets.CLDMV_BOT_EMAIL }}
        run: |
          set -euo pipefail
          KEYID="${{ steps.gpg.outputs.keyid }}"
          git config user.name  "$TAGGER_NAME"
          git config user.email "$TAGGER_EMAIL"
          git config user.signingkey "$KEYID"
          git config commit.gpgsign true
          git config gpg.program gpg
          echo "Using signing key: $KEYID as $TAGGER_NAME <$TAGGER_EMAIL>"

      - name: Create or move SIGNED annotated tag locally
        id: tagop
        env:
          TAG: ${{ inputs.tag_name }}
          MSG: ${{ inputs.tag_message }}
          FIRST: ${{ steps.shas.outputs.first }}
          LAST: ${{ steps.shas.outputs.last }}
          GPG_PASSPHRASE: ${{ secrets.CLDMV_BOT_GPG_PASSPHRASE }}
        run: |
          set -euo pipefail

          # Decide target (create at FIRST if missing, else move to HEAD)
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            TARGET="$LAST"; MODE="move"
            echo "Tag exists → moving to HEAD ($TARGET)"
          else
            TARGET="$FIRST"; MODE="create"
            echo "Tag missing → creating at FIRST commit ($TARGET)"
          fi

          # Ensure GPG agent has passphrase via loopback (no TTY prompts)
          export GPG_TTY=$(tty || true)
          # Sign once to warm-up agent (ignore failure if not needed)
          echo "$GPG_PASSPHRASE" | gpg --batch --yes --passphrase-fd 0 --pinentry-mode loopback \
               --quick-sign-key "$(git config user.signingkey)" >/dev/null 2>&1 || true

          # Create/move a SIGNED annotated tag (-s); -f for move case
          git tag -s -f -m "$MSG" "$TAG" "$TARGET"

          echo "pushed_tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "target_sha=${TARGET}" >> "$GITHUB_OUTPUT"
          echo "mode=${MODE}" >> "$GITHUB_OUTPUT"

      - name: Push tag using App installation token
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail
          # Use the app token for pushing (attributed to the App)
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}"
          # Force push in case we moved the tag
          git push origin "refs/tags/${{ inputs.tag_name }}" --force

      - name: Show verification via Git API (tag object)
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          REPO: ${{ github.repository }}
          TAG: ${{ inputs.tag_name }}
        shell: bash
        run: |
          set -euo pipefail
          GH="https://api.github.com/repos/${REPO}"

          REF_JSON=$(curl -sS -H "Authorization: Bearer $GH_TOKEN" \
                           -H "Accept: application/vnd.github+json" \
                           "${GH}/git/ref/tags/${TAG}")
          echo "$REF_JSON" | jq . > /tmp/ref.json

          OBJ_SHA=$(jq -r '.object.sha'  /tmp/ref.json)
          OBJ_TY=$(jq -r '.object.type' /tmp/ref.json)
          echo "Ref → $OBJ_TY $OBJ_SHA"

          if [[ "$OBJ_TY" == "tag" ]]; then
            TAG_JSON=$(curl -sS -H "Authorization: Bearer $GH_TOKEN" \
                              -H "Accept: application/vnd.github+json" \
                              "${GH}/git/tags/${OBJ_SHA}")
            echo "$TAG_JSON" | jq .
            echo "::notice title=Verification::.verification=$(echo "$TAG_JSON" | jq -c '.verification')"
          else
            echo "Note: ref is not pointing to a tag object (unexpected)."
          fi
